---
layout: article
title: golang与c++区别
tags: c++ golang go
key: 2022-02-21-difference_between_go_and_c++
---

## 前述
从c++转到golang, 有很多不习惯和新颖的地方。偶然看到一篇文章[《如何避免动态语言思维写go》](https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485520&idx=1&sn=b443754b9d1b411d3b19dcd874b236c9&chksm=fa80d9c7cdf750d10a303f4d2a8766efac8f8f09f38e2ae1cbc18017f24fa41428a083e79e5c&token=1604940402&lang=zh_CN#rd), 虽然写的比较粗略, 但还是提醒了我, 转语言需要去进行比较、转换编码思维。

## 参考
- [uber go style](https://github.com/uber-go/guide/blob/master/style.md)
- [effective go](https://go.dev/doc/effective_go)

## 区别
未完 待补全

### 基础
c++:
```c++
int a = 1;
void Func(string a) {
    if (a == "a") {

    }
    switch(1) {
        case 1:
            break;
        defualt:
            break;
    }
    return a == "b" ? a : "c";
}

// 对于多返回结果
struct DoubleResult {
    int result;
    int error;
};
DoubleResult DoubleResultFunc(string a) {
    DoubleResult res;
    return res;
}

/* 或者 返回代表errcode, 其余的返回包用引用或指针作为入参  这也是最常见的写法 在go中被认为是坏习惯
int DoubleResultFunc(string a, int& result) {
    result = 1;
    return 0;
}
*/

```

go:
```go
var a int = 1 // 或 a := 1
func Func(a string) {
    // 不需要括号
    if a == "a" {

    }
    // go的switch-case不需要break, 需要break的话是其他场景
    switch a {
        case "aa":
        case "bb":
        deautlt:
            a = "aa"
    }
    // go中没有三目运算符
    if a == "b" {
        return a
    } else {
        return "c"
    }
}

// 对于多返回结果 天然支持
func DoubleResultFunc(a string) int, error {
    return 1, nil
}
```

### 计算
```go
var a, b int
// go的交换数值可以这么写！
a, b = b, a
```

### 继承/接口
c++:
```c++
class Base {
    virtual TestInheritance() {}
};

class Test : public Base  {
    TestInheritance() override {}
};
```

go:
```go
type Base Interface {
    TestInheritance() error
}

// go没有类似继承的语法 接口随拿随用; 实现了interface里的所有函数 则可成为Base的替代(c++继承子类的概念和用法)
func (c *Test)TestInheritance() error {

}
```

### 方法
```go
type ByteSlice []byte
// method的接受体不一定非是结构体, 例中的byte slice也可
func (p *ByteSlice) Append(data []byte) {
    // ...
}
```